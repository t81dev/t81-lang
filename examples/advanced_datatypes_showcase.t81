// T81Lang advanced datatype showcase.
// Highlights: records/enums, Option/Result, Vector/Matrix/Tensor, BigInt/Fraction/Float, custom type aliases, string + bool handling.

type Axis2 = Vector[T81Float, 4];
type GridBatch = Tensor[T81Int, 3, 3, 2];
type FixedWindow = Vector[T81Fixed<4, 4>, 3];
type ObservationSet = Vector[Observation, 3];

record CalibrationProfile {
    id: T81BigInt;
    label: T81String;
    threshold: T81Fraction;
    active: bool;
}

enum AlertMode {
    Off;
    Scan;
    Alert(T81Float);
}

record Observation {
    qutrit: T81Qutrit;
    flag: bool;
    comment: T81String;
}

fn record_observation(idx: i32, profile: CalibrationProfile) -> Observation {
    let q = T81Qutrit(idx);
    return Observation {
        qutrit: q;
        flag: profile.active;
        comment: profile.label + "-obs";
    };
}

fn describe_profile(profile: CalibrationProfile) -> T81String {
    let status: T81String = if (profile.active) { "active" } else { "idle" };
    return profile.label + ":" + status;
}

fn compute_grid() -> GridBatch {
    let base: i32 = 1;
    return Tensor[T81Int, 3, 3, 2] [
        [
            [base; 3],
            [base + 1; 3],
            [base + 2; 3]
        ],
        [
            [base + 3; 3],
            [base + 4; 3],
            [base + 5; 3]
        ],
        [
            [base + 6; 3],
            [base + 7; 3],
            [base + 8; 3]
        ]
    ];
}

fn biased_axis() -> Axis2 {
    return [0.1t81, 0.3t81, 0.7t81, 1.1t81];
}

fn evaluate_alert(measurement: T81Float, mode: AlertMode) -> Option[T81Float] {
    match (mode) {
        Off => None;
        Scan => Some(measurement * 0.5t81);
        Alert(threshold) => {
            if (measurement > threshold) {
                Some(measurement - threshold)
            } else {
                None
            }
        }
    }
}

fn jitter_window(window: FixedWindow) -> T81Fixed<4, 4> {
    let base = window[0] + window[1] + window[2];
    return base / 3.0t81;
}

fn complex_lift(value: T81Float) -> T81Complex<2> {
    return T81Complex<2>(value, value * 0.5t81);
}

fn categorize(value: T81Uint) -> SensorState {
    if (value == T81Uint(0t81)) {
        Cold
    } else if (value % T81Uint(2t81) == 0t81) {
        Warm
    } else {
        Alert(0.5t81)
    }
}

fn qutrit_balance(observations: ObservationSet) -> T81Float {
    let mut total: T81Float = 0.0t81;
    var idx: i32 = 0;
    loop @bounded(infinite) {
        if (idx >= 3) {
            break;
        }
        total = total + T81Float(observations[idx].qutrit);
        idx = idx + 1;
    }
    return total / 3.0t81;
}

fn observe_classes(profiles: Vector[CalibrationProfile, 2]) -> ObservationSet {
    let mut result: ObservationSet = [
        record_observation(0, profiles[0]),
        record_observation(1, profiles[1]),
        record_observation(0, profiles[0])
    ];
    return result;
}

fn safe_ratio(numerator: T81Fraction, denominator: T81Fraction) -> Result[T81Float, T81String] {
    if (denominator == 0/1t81) {
        return Err("denominator zero");
    }
    let frac = numerator / denominator;
    return Ok(T81Float(frac));
}

fn profile_score(profile: CalibrationProfile, grid: GridBatch) -> Result[i32, T81String] {
    let area: i32 = grid[0][0][0] + grid[2][2][1];
    if (!profile.active) {
        return Err("profile disabled");
    }
    let diff: T81Float = vector_average(biased_axis());
    if (diff > T81Float(profile.threshold)) {
        return Ok(area);
    }
    return Err("diff below threshold");
}

fn mark_alerts(profiles: Vector[CalibrationProfile, 2], mode: AlertMode) -> Vector[T81String, 2] {
    let mut messages: Vector[T81String, 2] = ["", ""];
    var idx: i32 = 0;
    loop @bounded(infinite) {
        if (idx >= 2) {
            break;
        }
        let profile = profiles[idx];
        let label = describe_profile(profile);
        let delta = evaluate_alert(T81Float(profile.threshold), mode);
        match (delta) {
            Some(value) => messages[idx] = label + " delta=" + value;
            None => messages[idx] = label + " idle";
        }
        idx = idx + 1;
    }
    return messages;
}

fn vector_average(axis: Axis2) -> T81Float {
    let total: T81Float = axis[0] + axis[1] + axis[2] + axis[3];
    return total / 4.0t81;
}

fn evaluate_reviews() -> i32 {
    let profiles: Vector[CalibrationProfile, 2] = [
        CalibrationProfile { id: 123t81; label: "alpha"; threshold: 1/3t81; active: true; },
        CalibrationProfile { id: 456t81; label: "beta"; threshold: 1/2t81; active: false; }
    ];
    let mode: AlertMode = Alert(0.4t81);
    let alerts = mark_alerts(profiles, mode);
    let grid = compute_grid();
    let jitted = jitter_window([{0.1t81}, {0.2t81}, {0.3t81}]);
    let tensor_sum: i32 = grid[0][0][0] + grid[1][1][1];
    let observations = observe_classes(profiles);
    match (profiles[0].active) {
        true => _ = alerts[0];
        false => _ = "alpha paused";
    };
    _ = alerts[1];
    let score_res = profile_score(profiles[0], grid);
    match (score_res) {
        Ok(value) => return value + tensor_sum;
        Err(_) => return tensor_sum;
    }
}

fn main() -> i32 {
    let ratio = safe_ratio(3/5t81, 1/2t81);
    let _ratio_note: T81String = match (ratio) {
        Ok(value) => "ratio=" + value;
        Err(msg) => msg;
    };

    let window: FixedWindow = [
        T81Fixed<4, 4>(0.1t81),
        T81Fixed<4, 4>(0.2t81),
        T81Fixed<4, 4>(0.3t81)
    ];
    let _jitter = jitter_window(window);
    let _complex = complex_lift(2.0t81);
    let _observations = observe_classes([
        CalibrationProfile { id: 1t81; label: "alpha"; threshold: 1/3t81; active: true; },
        CalibrationProfile { id: 2t81; label: "beta"; threshold: 1/4t81; active: false; }
    ]);

    return evaluate_reviews();
}
